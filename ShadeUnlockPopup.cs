#nullable enable

using System;
using LegacyoftheAbyss.Shade;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// Simple HUD overlay that surfaces unlock notifications generated by <see cref="ShadeRuntime"/>.
/// The popup listens for dispatcher events, keeps a small queue alive across scene loads, and
/// respects pause/menu visibility so messages never compete with menus.
/// </summary>
public sealed class ShadeUnlockPopup : MonoBehaviour
{
    private const float FadeSpeed = 6f;
    private const float BaseWidth = 560f;
    private const float BaseHeight = 120f;
    private const float BaseVerticalOffset = 140f;

    private static readonly Color AbilityColor = new Color(0.87f, 0.95f, 1f, 1f);
    private static readonly Color CharmColor = new Color(1f, 0.92f, 0.75f, 1f);
    private static readonly Color SpellColor = new Color(0.8f, 0.95f, 0.85f, 1f);

    private static Sprite? s_backgroundSprite;

    private Canvas? targetCanvas;
    private Func<float>? scaleProvider;
    private RectTransform? container;
    private CanvasGroup? containerGroup;
    private Image? background;
    private Text? messageLabel;
    private ShadeRuntime.ShadeUnlockNotification? activeNotification;
    private float activeTimer;
    private float activeDuration;
    private float nextAvailableTime;
    private bool isInitialized;
    private bool subscribed;
    private bool queueDirty;
    private float lastAppliedScale = -1f;

    public void Initialize(Canvas canvas, Func<float> scale)
    {
        targetCanvas = canvas;
        scaleProvider = scale;

        if (!isInitialized)
        {
            BuildUI();
            isInitialized = true;
        }

        ApplyScale(force: true);
        Subscribe();
        queueDirty = ShadeRuntime.HasPendingNotifications;
    }

    private void OnEnable()
    {
        if (isInitialized)
        {
            Subscribe();
        }
    }

    private void OnDisable()
    {
        Unsubscribe();
    }

    private void OnDestroy()
    {
        Unsubscribe();
    }

    private void Subscribe()
    {
        if (subscribed)
        {
            return;
        }

        ShadeRuntime.NotificationsChanged += HandleQueueChanged;
        subscribed = true;
    }

    private void Unsubscribe()
    {
        if (!subscribed)
        {
            return;
        }

        ShadeRuntime.NotificationsChanged -= HandleQueueChanged;
        subscribed = false;
    }

    private void HandleQueueChanged()
    {
        queueDirty = true;
    }

    private void BuildUI()
    {
        if (targetCanvas == null)
        {
            return;
        }

        var root = new GameObject("ShadeUnlockPopupRoot");
        container = root.AddComponent<RectTransform>();
        container.SetParent(targetCanvas.transform, false);
        container.anchorMin = new Vector2(0.5f, 1f);
        container.anchorMax = new Vector2(0.5f, 1f);
        container.pivot = new Vector2(0.5f, 1f);
        container.anchoredPosition = new Vector2(0f, -BaseVerticalOffset);

        containerGroup = root.AddComponent<CanvasGroup>();
        containerGroup.alpha = 0f;
        containerGroup.interactable = false;
        containerGroup.blocksRaycasts = false;

        var backgroundGO = new GameObject("Background");
        backgroundGO.transform.SetParent(container, false);
        background = backgroundGO.AddComponent<Image>();
        background.rectTransform.anchorMin = Vector2.zero;
        background.rectTransform.anchorMax = Vector2.one;
        background.rectTransform.offsetMin = new Vector2(-18f, -14f);
        background.rectTransform.offsetMax = new Vector2(18f, 14f);
        background.color = new Color(0f, 0f, 0f, 0.72f);
        background.raycastTarget = false;
        background.sprite = EnsureBackgroundSprite();
        background.type = Image.Type.Sliced;

        var messageGO = new GameObject("Message");
        messageGO.transform.SetParent(container, false);
        messageLabel = messageGO.AddComponent<Text>();
        messageLabel.rectTransform.anchorMin = new Vector2(0.08f, 0.15f);
        messageLabel.rectTransform.anchorMax = new Vector2(0.92f, 0.85f);
        messageLabel.rectTransform.offsetMin = Vector2.zero;
        messageLabel.rectTransform.offsetMax = Vector2.zero;
        messageLabel.alignment = TextAnchor.MiddleCenter;
        messageLabel.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
        messageLabel.fontSize = 30;
        messageLabel.horizontalOverflow = HorizontalWrapMode.Wrap;
        messageLabel.verticalOverflow = VerticalWrapMode.Overflow;
        messageLabel.raycastTarget = false;
        messageLabel.text = string.Empty;
        messageLabel.color = AbilityColor;

        var shadow = messageGO.AddComponent<Shadow>();
        shadow.effectColor = new Color(0f, 0f, 0f, 0.85f);
        shadow.effectDistance = new Vector2(2f, -2f);
    }

    private static Sprite EnsureBackgroundSprite()
    {
        if (s_backgroundSprite != null)
        {
            return s_backgroundSprite;
        }

        var tex = new Texture2D(4, 4, TextureFormat.ARGB32, false);
        for (int x = 0; x < tex.width; x++)
        {
            for (int y = 0; y < tex.height; y++)
            {
                tex.SetPixel(x, y, Color.white);
            }
        }

        tex.Apply();
        s_backgroundSprite = Sprite.Create(tex, new Rect(0f, 0f, tex.width, tex.height), new Vector2(0.5f, 0.5f), 16f, 1, SpriteMeshType.FullRect);
        s_backgroundSprite.name = "ShadeUnlockPopupBackground";
        return s_backgroundSprite;
    }

    private void Update()
    {
        if (!isInitialized)
        {
            return;
        }

        ApplyScale();

        bool suppressed = ShouldSuppress();
        if (suppressed)
        {
            FadeTowards(0f);
        }

        if (ArePopupsMuted())
        {
            ClearActiveNotification();
            FadeTowards(0f);
            return;
        }

        if (activeNotification != null)
        {
            if (suppressed)
            {
                return;
            }

            FadeTowards(1f);
            activeTimer += Time.unscaledDeltaTime;
            if (activeTimer >= activeDuration)
            {
                ClearActiveNotification();
                nextAvailableTime = Time.unscaledTime + GetConfiguredDelay();
            }

            return;
        }

        FadeTowards(0f);

        if (suppressed)
        {
            return;
        }

        if (!queueDirty && !ShadeRuntime.HasPendingNotifications)
        {
            return;
        }

        if (Time.unscaledTime < nextAvailableTime)
        {
            return;
        }

        if (ShadeRuntime.TryDequeueNotification(out var notification))
        {
            Present(notification);
            queueDirty = ShadeRuntime.HasPendingNotifications;
        }
        else
        {
            queueDirty = false;
        }
    }

    private void Present(ShadeRuntime.ShadeUnlockNotification notification)
    {
        activeNotification = notification;
        activeTimer = 0f;
        activeDuration = GetConfiguredDuration(notification);

        if (messageLabel != null)
        {
            messageLabel.text = notification.Message;
            messageLabel.color = GetColorFor(notification.Type);
        }

        FadeTowards(1f);
    }

    private void ClearActiveNotification()
    {
        activeNotification = null;
        activeTimer = 0f;
        activeDuration = 0f;
        if (messageLabel != null)
        {
            messageLabel.text = string.Empty;
        }
    }

    private void ApplyScale(bool force = false)
    {
        if (container == null)
        {
            return;
        }

        float scale = 1f;
        if (scaleProvider != null)
        {
            try
            {
                scale = Mathf.Max(0.5f, scaleProvider());
            }
            catch
            {
                scale = 1f;
            }
        }

        if (!force && Mathf.Approximately(scale, lastAppliedScale))
        {
            return;
        }

        container.sizeDelta = new Vector2(BaseWidth * scale, BaseHeight * scale);
        container.anchoredPosition = new Vector2(0f, -BaseVerticalOffset * scale);

        if (background != null)
        {
            background.rectTransform.offsetMin = new Vector2(-18f * scale, -14f * scale);
            background.rectTransform.offsetMax = new Vector2(18f * scale, 14f * scale);
        }

        if (messageLabel != null)
        {
            int fontSize = Mathf.Clamp(Mathf.RoundToInt(30f * scale), 18, 60);
            messageLabel.fontSize = fontSize;
            messageLabel.lineSpacing = Mathf.Lerp(1f, 1.2f, Mathf.Clamp01(scale - 1f));
        }

        lastAppliedScale = scale;
    }

    private void FadeTowards(float target)
    {
        if (containerGroup == null)
        {
            return;
        }

        float current = containerGroup.alpha;
        if (Mathf.Approximately(current, target))
        {
            containerGroup.alpha = target;
            return;
        }

        float step = Mathf.Max(0.01f, FadeSpeed * Time.unscaledDeltaTime);
        containerGroup.alpha = Mathf.MoveTowards(current, target, step);
    }

    private static bool ShouldSuppress()
    {
        try
        {
            if (ShadeSettingsMenu.IsShowing)
            {
                return true;
            }
        }
        catch
        {
        }

        try
        {
            var gm = GameManager.instance;
            if (gm != null)
            {
                if (!gm.IsGameplayScene())
                {
                    return true;
                }

                if (gm.IsGamePaused())
                {
                    return true;
                }
            }
        }
        catch
        {
        }

        return false;
    }

    private static bool ArePopupsMuted()
    {
        try
        {
            return ModConfig.Instance.shadeUnlockPopupsMuted;
        }
        catch
        {
            return false;
        }
    }

    private static float GetConfiguredDelay()
    {
        try
        {
            return Mathf.Max(0f, ModConfig.Instance.shadeUnlockPopupDelaySeconds);
        }
        catch
        {
            return 0.75f;
        }
    }

    private static float GetConfiguredDuration(ShadeRuntime.ShadeUnlockNotification notification)
    {
        float configured = GetBaseDuration();
        if (configured > 0f)
        {
            return Mathf.Max(0.5f, configured);
        }

        float duration = notification.Duration;
        if (duration <= 0f || float.IsNaN(duration) || float.IsInfinity(duration))
        {
            return ShadeRuntime.ShadeUnlockNotification.DefaultDuration;
        }

        return Mathf.Max(0.5f, duration);
    }

    private static float GetBaseDuration()
    {
        try
        {
            return ModConfig.Instance.shadeUnlockPopupDurationSeconds;
        }
        catch
        {
            return ShadeRuntime.ShadeUnlockNotification.DefaultDuration;
        }
    }

    private static Color GetColorFor(ShadeUnlockNotificationType type)
    {
        return type switch
        {
            ShadeUnlockNotificationType.Charm => CharmColor,
            ShadeUnlockNotificationType.Spell => SpellColor,
            _ => AbilityColor
        };
    }
}

