
            var poly = go.AddComponent<PolygonCollider2D>();
            poly.isTrigger = true;
            // Build wedge polygon with apex at (0,0) and arc up
            int segments = 8;
            float half = degrees * 0.5f;
            List<Vector2> pts = new List<Vector2>();
            pts.Add(Vector2.zero);
            for (int i = 0; i <= segments; i++)
            {
                float a = Mathf.Lerp(-half, half, i / (float)segments);
                float ang = (90f + a) * Mathf.Deg2Rad; // around up axis
                Vector2 p = new Vector2(Mathf.Cos(ang), Mathf.Sin(ang)) * height;
                pts.Add(p);
            }
            poly.SetPath(0, pts.ToArray());

            var aoe = go.AddComponent<ShadeAoE>();
            aoe.damage = damage;
            aoe.hornetRoot = hornetTransform;
            aoe.lifeSeconds = lifeSeconds;

            IgnoreHornetForCollider(poly);
        }

        private IEnumerator DescendingDarkRoutine(int totalDamage)
        {
            isCastingSpell = true;
            // Cast time ~0.25s
            float castTime = 0.25f;
            float prevVelY = rb ? rb.linearVelocity.y : 0f;
            if (rb) rb.linearVelocity = Vector2.zero;
            float t = 0f;
            while (t < castTime)
            {
                t += Time.deltaTime;
                yield return null;
            }

            // Enemy i-frames during descent (not hazards)
            hurtCooldown = Mathf.Max(hurtCooldown, 0.6f);

            // Find ground below
            Vector2 start = transform.position;
            float maxDist = 60f;
            var hits = Physics2D.RaycastAll(start, Vector2.down, maxDist);
            RaycastHit2D? pick = null;
            foreach (var h in hits)
            {
                if (!h.collider) continue;
                if (h.collider.isTrigger) continue;
                if (h.collider.transform == transform || h.collider.transform.IsChildOf(transform)) continue;
                pick = h; break;
            }

            Vector3 targetPos = transform.position + Vector3.down * 8f; // fallback
            float groundY = targetPos.y;
            float extY = bodyCol ? bodyCol.bounds.extents.y : 0.7f;
            if (pick.HasValue)
            {
                groundY = pick.Value.point.y;
                targetPos = new Vector3(transform.position.x, groundY + extY + 0.02f, transform.position.z);
            }

            // Quick drop over 0.12s
            float dropTime = 0.12f;
            Vector3 from = transform.position;
            float elapsed = 0f;
            while (elapsed < dropTime)
            {
                elapsed += Time.deltaTime;
                float u = Mathf.Clamp01(elapsed / dropTime);
                Vector3 p = Vector3.Lerp(from, targetPos, u*u); // ease in
                TeleportToPosition(p);
                yield return null;
            }
            TeleportToPosition(targetPos);

            // If landing area is a hazard, skip the impact
            if (IsHazardAtPosition(new Vector2(targetPos.x, groundY + 0.2f), 0.8f))
            {
                isCastingSpell = false;
                yield break;
            }

            // Spawn two hitboxes: ground strip (10 units wide), and teardrop (6x8) above
            int half = Mathf.Max(1, Mathf.RoundToInt(totalDamage * 0.5f));
            SpawnQuakeImpact(groundY, half);
            SpawnQuakeTeardrop(groundY, half);

            // Small delay to keep i-frames briefly after impact
            yield return new WaitForSeconds(0.1f);
            if (rb) rb.linearVelocity = new Vector2(rb.linearVelocity.x, prevVelY);
            isCastingSpell = false;
        }

        private bool IsHazardAtPosition(Vector2 pos, float radius)
        {
            try
            {
                var hits = Physics2D.OverlapCircleAll(pos, radius, ~0, -Mathf.Infinity, Mathf.Infinity);
                foreach (var c in hits)
                {
                    if (!c) continue;
                    if (c.transform == transform || c.transform.IsChildOf(transform)) continue;
                    var dh = c.GetComponentInParent<DamageHero>();
                    if (dh != null)
                    {
                        var hz = GetHazardType(dh);
                        if (IsTerrainHazard(hz)) return true;
                    }
                }
            }
            catch { }
            return false;
        }

        private void SpawnQuakeImpact(float groundY, int damage)
        {
            var go = new GameObject("ShadeQuakeStrip");
            go.transform.position = new Vector3(transform.position.x, groundY + 0.5f, transform.position.z);
            go.tag = "Hero Spell";
            int spellLayer = LayerMask.NameToLayer("Hero Spell");
            int atkLayer = LayerMask.NameToLayer("Hero Attack");
            if (spellLayer >= 0) go.layer = spellLayer; else if (atkLayer >= 0) go.layer = atkLayer;

            var box = go.AddComponent<BoxCollider2D>();
            box.isTrigger = true;
            box.size = new Vector2(10f, 1.0f);

            var aoe = go.AddComponent<ShadeAoE>();
            aoe.damage = damage;
            aoe.hornetRoot = hornetTransform;
            aoe.lifeSeconds = 0.25f;

            IgnoreHornetForCollider(box);
        }

        private void SpawnQuakeTeardrop(float groundY, int damage)
        {
            var go = new GameObject("ShadeQuakeTear");
            // Place center so bottom is at ground contact near the shade's position.
            float height = 8f; float width = 6f;
            float centerY = groundY + (height * 0.5f);
            go.transform.position = new Vector3(transform.position.x, centerY, transform.position.z);
            go.tag = "Hero Spell";
            int spellLayer = LayerMask.NameToLayer("Hero Spell");
            int atkLayer = LayerMask.NameToLayer("Hero Attack");
            if (spellLayer >= 0) go.layer = spellLayer; else if (atkLayer >= 0) go.layer = atkLayer;

            var cap = go.AddComponent<CapsuleCollider2D>();
            cap.isTrigger = true;
            cap.direction = CapsuleDirection2D.Vertical;
            cap.size = new Vector2(width, height);

            var aoe = go.AddComponent<ShadeAoE>();
            aoe.damage = damage;
            aoe.hornetRoot = hornetTransform;
            aoe.lifeSeconds = 0.25f;

            IgnoreHornetForCollider(cap);
        }

        private void SetupPhysics()
        {
            rb = GetComponent<Rigidbody2D>();
            if (!rb) rb = gameObject.AddComponent<Rigidbody2D>();
            rb.bodyType = RigidbodyType2D.Dynamic;
            rb.gravityScale = 0f;
            rb.freezeRotation = true;
            rb.collisionDetectionMode = CollisionDetectionMode2D.Continuous;

            bodyCol = GetComponent<Collider2D>();
            if (!bodyCol)
            {
                var cap = gameObject.AddComponent<CapsuleCollider2D>();
                cap.direction = CapsuleDirection2D.Vertical;
                cap.size = new Vector2(0.9f, 1.4f);
                cap.isTrigger = false;
                bodyCol = cap;
            }
            else
            {
                bodyCol.isTrigger = false;
            }

            // Add an additional trigger collider to interact with Hornet's attack triggers (for pogo)
            try
            {
                var existingTriggers = GetComponents<Collider2D>();
                bool hasTrigger = false;
                foreach (var c in existingTriggers) if (c && c.isTrigger) { hasTrigger = true; break; }
                if (!hasTrigger)
                {
                    var trigger = gameObject.AddComponent<CapsuleCollider2D>();
                    trigger.direction = CapsuleDirection2D.Vertical;
                    trigger.size = new Vector2(0.95f, 1.5f);
                    trigger.isTrigger = true;
                }
            }
            catch { }

            try
            {
                var hc = HeroController.instance;
                if (hc)
                {
                    // Place shade on a non-hero layer to avoid triggering transitions and interactables
                    int heroLayer = hc.gameObject.layer; // typically 9
                    int desiredLayer = LayerMask.NameToLayer("Default");
                    if (desiredLayer < 0 || desiredLayer == heroLayer)
                    {
                        // Fallback to a safe built-in layer that is not the hero layer
                        int ignoreRaycast = LayerMask.NameToLayer("Ignore Raycast");
                        desiredLayer = (ignoreRaycast >= 0 && ignoreRaycast != heroLayer) ? ignoreRaycast : 0;
                    }

                    gameObject.layer = desiredLayer;
                    // Apply to immediate children we control
                    var allTransforms = GetComponentsInChildren<Transform>(true);
                    foreach (var t in allTransforms)
                    {
                        if (!t) continue;
                        t.gameObject.layer = desiredLayer;
                    }

                    // Still ignore collisions with Hornet (handled in a helper so we can call it later too)
                    EnsureIgnoreHornetCollisions();

                    // Initial enemy ignore pass
                    RefreshCollisionIgnores();
                }
            }
            catch { }
        }

        private void RefreshCollisionIgnores()
        {
            try
            {
                var myCols = GetComponentsInChildren<Collider2D>(true);
                if (myCols == null || myCols.Length == 0) return;

                // Ignore physical collisions with enemies (objects with HealthManager) but keep triggers for damage/hazards
                HealthManager[] enemies = null;
                try { enemies = Object.FindObjectsOfType<HealthManager>(); }
                catch { enemies = null; }
                if (enemies != null)
                {
                    foreach (var hm in enemies)
