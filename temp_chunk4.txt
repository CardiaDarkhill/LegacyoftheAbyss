                foreach (var r in shadeLightRenderers)
                {
                    if (!r) continue;
                    r.enabled = true;
                    r.sortingLayerID = baseLayer;
                    r.sortingOrder = baseOrder - 1;
                }
            }
            catch { }
        }

        private IEnumerator EnableShadeLightNextFrame()
        {
            yield return null;
        }

        private static void EnsureSimpleLightResources()
        {
            try
            {
                if (s_simpleQuadMesh == null)
                {
                    s_simpleQuadMesh = new Mesh();
                    s_simpleQuadMesh.name = "ShadeLightQuad";
                    s_simpleQuadMesh.vertices = new Vector3[]
                    {
                        new Vector3(-0.5f, -0.5f, 0f),
                        new Vector3( 0.5f, -0.5f, 0f),
                        new Vector3(-0.5f,  0.5f, 0f),
                        new Vector3( 0.5f,  0.5f, 0f)
                    };
                    s_simpleQuadMesh.uv = new Vector2[] {
                        new Vector2(0,0), new Vector2(1,0), new Vector2(0,1), new Vector2(1,1)
                    };
                    s_simpleQuadMesh.triangles = new int[] { 0, 2, 1, 2, 3, 1 };
                    s_simpleQuadMesh.RecalculateNormals();
                }
                if (s_simpleLightTex == null)
                {
                    int size = 128;
                    s_simpleLightTex = new Texture2D(size, size, TextureFormat.ARGB32, false);
                    s_simpleLightTex.filterMode = FilterMode.Bilinear;
                    for (int y = 0; y < size; y++)
                    {
                        for (int x = 0; x < size; x++)
                        {
                            float nx = (x + 0.5f) / size * 2f - 1f;
                            float ny = (y + 0.5f) / size * 2f - 1f;
                            float r = Mathf.Sqrt(nx * nx + ny * ny);
                            float a = Mathf.Clamp01(1f - r);
                            a = Mathf.Pow(a, 3.5f) * 0.55f;
                            s_simpleLightTex.SetPixel(x, y, new Color(1f, 1f, 1f, a));
                        }
                    }
                    s_simpleLightTex.Apply();
                }
                if (s_simpleAdditiveMat == null)
                {
                    var shader = Shader.Find("Sprites/Default") ?? Shader.Find("Unlit/Transparent");
                    s_simpleAdditiveMat = new Material(shader)
                    {
                        name = "ShadeLightAdditiveMat",
                        mainTexture = s_simpleLightTex,
                        renderQueue = 3000
                    };
                    try { s_simpleAdditiveMat.SetColor("_Color", new Color(1f, 1f, 1f, 0.35f)); } catch { }
                }
            }
            catch { }
        }

        private static bool IsTerrainHazard(GlobalEnums.HazardType hz)
        {
            switch (hz)
            {
                case GlobalEnums.HazardType.SPIKES:
                case GlobalEnums.HazardType.ACID:
                case GlobalEnums.HazardType.LAVA:
                case GlobalEnums.HazardType.PIT:
                case GlobalEnums.HazardType.COAL:
                case GlobalEnums.HazardType.ZAP:
                case GlobalEnums.HazardType.SINK:
                case GlobalEnums.HazardType.STEAM:
                case GlobalEnums.HazardType.COAL_SPIKES:
                case GlobalEnums.HazardType.RESPAWN_PIT:
                    return true;
                default:
                    return false;
            }
        }

        private void HandleTeleportChannel()
        {
            teleportCooldownTimer = Mathf.Max(0f, teleportCooldownTimer - Time.deltaTime);

            // Start channel
            if (!isChannelingTeleport && teleportCooldownTimer <= 0f && Input.GetKeyDown(TeleportKey))
            {
                isChannelingTeleport = true;
                teleportChannelTimer = teleportChannelTime;
            }

            if (!isChannelingTeleport) return;

            // Visual hint: fade sprite slightly while channeling
            try
            {
                if (sr)
                {
                    var c = sr.color; c.a = 0.6f; sr.color = c;
                }
            }
            catch { }

            teleportChannelTimer -= Time.deltaTime;
            if (teleportChannelTimer <= 0f)
            {
                TeleportToHornet();
                teleportCooldownTimer = teleportCooldown;
                isChannelingTeleport = false;
                // restore sprite alpha
                try { if (sr) { var c = sr.color; c.a = 0.9f; sr.color = c; } } catch { }
            }

            // Cancel on movement or attack input
            if (Input.GetKeyDown(KeyCode.Escape) || Input.GetMouseButtonDown(0) || Input.GetKeyDown(NailKey) || Input.GetKeyDown(FireKey))
            {
                isChannelingTeleport = false;
                try { if (sr) { var c = sr.color; c.a = 0.9f; sr.color = c; } } catch { }
            }
        }

        private int GetHornetNailDamage()
        {
            try
            {
                var gm = GameManager.instance;
                var pd = gm != null ? gm.playerData : null;
                if (pd == null) return 5;
                int baseDmg = Mathf.Max(1, pd.nailDamage);
                bool bound = false;
                try { bound = BossSequenceController.BoundNail; } catch { bound = false; }
                if (bound)
                {
                    int boundVal = 0;
                    try { boundVal = BossSequenceController.BoundNailDamage; } catch { boundVal = baseDmg; }
                    return Mathf.Min(baseDmg, Mathf.Max(1, boundVal));
                }
                return baseDmg;
            }
            catch { return 5; }
        }
    }
}
