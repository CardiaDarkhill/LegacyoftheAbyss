                    {
                        if (Mathf.Abs(v) < 0.35f && facing >= 0)
                        {
                            var altSlashProp = hc.GetType().GetProperty("AlternateSlash", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)?.GetValue(hc, null) as NailSlash;
                            if (altSlashProp != null && !string.IsNullOrEmpty(altSlashProp.animName))
                            {
                                nailSlash.animName = altSlashProp.animName;
                            }
                        }
                    }
                    catch { }

                    // Re-enable hitboxes after patching and ignoring Hornet
                    foreach (var d in tempDamagers) if (d) d.enabled = true;
                    foreach (var c in tempCols) if (c) c.enabled = true;

                    nailSlash.StartSlash();

                    // Ensure we fully end the hitboxes when damage ends to avoid lingering hits
                    try
                    {
                        var primaryDamager = nailSlash.EnemyDamager;
                        if (primaryDamager != null)
                        {
                            System.Action onDamaged = null; System.Action<bool> onEnded = null;
                            onDamaged = () =>
                            {
                                shadeSoul = Mathf.Min(shadeSoulMax, shadeSoul + soulGainPerHit);
                                PushSoulToHud();
                                CheckHazardOverlap();
                            };
                            primaryDamager.DamagedEnemy += onDamaged;

                            onEnded = (didHit) =>
                            {
                                try { primaryDamager.DamagedEnemy -= onDamaged; } catch { }
                                try { nailSlash.EndedDamage -= onEnded; } catch { }
                                try {
                                    var damagersAll = slash.GetComponentsInChildren<DamageEnemies>(true);
                                    foreach (var de in damagersAll) if (de) de.enabled = false;
                                    var colsAll = slash.GetComponentsInChildren<Collider2D>(true);
                                    foreach (var c2 in colsAll) if (c2) c2.enabled = false;
                                } catch { }
                                try { slash.SetActive(false); } catch { }
                                try { Destroy(slash); } catch { }
                            };
                            nailSlash.EndedDamage += onEnded;
                        }
                    }
                    catch { }
                    // Failsafe to ensure no lingering colliders/hitboxes
                    StartCoroutine(DisableSlashAfterWindow(slash, 0.3f));
                }
            else
            {
                // No NailSlash component found
            }

            StartCoroutine(PostConfigureSlash(slash, v, facing, hc));
        }

        private IEnumerator PostConfigureSlash(GameObject slash, float v, int facingSign, HeroController hc)
        {
            yield return null;
            if (!slash) yield break;
            try
            {
                var recoils = slash.GetComponentsInChildren<NailSlashRecoil>(true);
                foreach (var r in recoils) if (r) Destroy(r);

                var damagers = slash.GetComponentsInChildren<DamageEnemies>(true);
                var srcField = typeof(DamageEnemies).GetField("sourceIsHero", BindingFlags.Instance | BindingFlags.NonPublic);
                var ihField  = typeof(DamageEnemies).GetField("isHeroDamage", BindingFlags.Instance | BindingFlags.NonPublic);
                var dirField = typeof(DamageEnemies).GetField("direction", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                var moveDirField = typeof(DamageEnemies).GetField("moveDirection", BindingFlags.Instance | BindingFlags.NonPublic);
                var flipBehindField = typeof(DamageEnemies).GetField("flipDirectionIfBehind", BindingFlags.Instance | BindingFlags.NonPublic);
                var fwdVecField = typeof(DamageEnemies).GetField("forwardVector", BindingFlags.Instance | BindingFlags.NonPublic);
                var onlyEnemiesField = typeof(DamageEnemies).GetField("onlyDamageEnemies", BindingFlags.Instance | BindingFlags.NonPublic);
                var setOnlyEnemies = typeof(DamageEnemies).GetMethod("setOnlyDamageEnemies", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                var ignoreNailPosField = typeof(DamageEnemies).GetField("ignoreNailPosition", BindingFlags.Instance | BindingFlags.NonPublic);
                var silkGenField = typeof(DamageEnemies).GetField("silkGeneration", BindingFlags.Instance | BindingFlags.NonPublic);
                var doesNotGenSilkField = typeof(DamageEnemies).GetField("doesNotGenerateSilk", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
                var attackTypeField = typeof(DamageEnemies).GetField("attackType", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

                float dir = 0f;
                if (v > 0.35f) dir = 90f; else if (v < -0.35f) dir = 270f; else dir = (facingSign >= 0 ? 0f : 180f);

                foreach (var d in damagers)
                {
                    if (!d) continue;
                    try { srcField?.SetValue(d, false); } catch { }
                    try { ihField?.SetValue(d, false); } catch { }
                    try { attackTypeField?.SetValue(d, AttackTypes.Generic); } catch { }
                    try { dirField?.SetValue(d, dir); } catch { }
                    try { moveDirField?.SetValue(d, false); } catch { }
                    try { flipBehindField?.SetValue(d, false); } catch { }
                    try { fwdVecField?.SetValue(d, Vector2.zero); } catch { }
                    try { if (setOnlyEnemies != null) setOnlyEnemies.Invoke(d, new object[] { false }); else onlyEnemiesField?.SetValue(d, false); } catch { }
                    try { ignoreNailPosField?.SetValue(d, true); } catch { }
                    try { if (silkGenField != null) { var enumType = silkGenField.FieldType; var noneVal = System.Enum.ToObject(enumType, 0); silkGenField.SetValue(d, noneVal);} } catch { }
